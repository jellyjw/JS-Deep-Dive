## 변수

컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다. 만약 10+20 이라는 연산을 수행하라는 명령을 내릴 경우, 임의의 메모리 주소에 다음 값(10, 20)이 저장되고, CPU에 의해 연산이 수행된다.

```jsx
10 + 20; // 30
```

이렇게 연산한 값을 재사용할 수 없다면 의미가 없을 것이다. 그래서 우리는 변수라는 메커니즘을 통해 연산 결과를 저장하고, 재사용할 수 있게 된다.

즉, 변수란 **하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름** 을 말한다.

메모리 공간에 저장된 값을 식별할수 있는 이름을 **변수명** 이라고 하고, 변수에 저장된 값을 **변수 값** 이라고 하며, 변수에 값을 저장하는 것을 **할당** 이라고 하고, 변수에 저장된 값을 읽어 들이는 것을 **참조** 라고 한다.

### 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

```jsx
var result = 30;
```

여기서 식별자는 `result` 가 되며 식별자를 통해 값 30을 식별할 수 있다. 하지만 중요한 사실은 식별자는 **값을 기억하는게 아닌 메모리 주소를 기억**하고 있다는 점이다.

즉, 식별자는 메모리 주소에 붙인 이름이다.

### 변수 선언 및 할당

자바스크립트 엔진에 의해 변수 선언은 다음과 같은 2단계를 거쳐 수행된다.

1. **선언 단계**
   1. 변수 이름을 등록해서 JS 엔진에 변수의 존재를 알림
2. **초기화 단계**
   1. 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined` 를 할당해 초기화한다.

기존에는 `var` 키워드를 통해서만 변수 선언이 가능했지만, ES6부터 `var` 의 단점을 보완하기 위해 `let` , `const` 와 같은 키워드가 도입되었다.

```jsx
var score; // undefined
```

변수를 선언하고 변수에 값을 할당하지 않았기 때문에 확보된 메모리 공간이 비어있을 것 같지만, 자바스크립트 엔진에 의해 변수 선언시 암묵적으로 `undefined` 라는 값이 할당된다.

`var` 키워드는 변수 선언과 초기화가 동시에 진행된다. 초기화란 일반적으로 변수가 선언된 이후 최초로 값을 할당하는 것을 말하는데, 만약 초기화 단계를 거치지 않을경우 다른 애플리케이션에서 사용했던 값이 남아있을 수 있다.

```jsx
var result = 10;
result = 4;
var result = "hi";
```

`var` 키워드는 재선언, 재할당이 모두 가능하다. 이는 안전한 프로그래밍을 위해 권장되는 방법이 아니며 변하지 않는 값의 경우 `const` 키워드를 사용하는것이 좋은데, 이러한 단점들을 보완하기 위해 ES6에서 도입된 키워드가 `let` 과 `const` 이다.

### 변수 선언의 실행 시점

```jsx
console.log(result); // undefined
var result;
```

result 라는 변수가 선언되기도 전에 변수를 참조했는데 syntax error가 발생하지 않고 `undefined` 라는 값을 출력했다. 그 이유는 **변수 선언이 소스코드가 한줄씩 순차적으로 실행되는 시점인 런타임이 아닌 그 이전 단계에서 먼저 실행되기 때문**이다.

### 변수 호이스팅

이처럼 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅** 이라 한다. 변수 선언뿐 아니라 `var` , `let` , `const` , `function` , `class` 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

### 값의 할당

```jsx
var score = 80;
var result;
result = 2;
```

변수 선언과 값의 할당을 따로 하거나, 하나의 문으로 단축 표현해도 동일하게 동작한다. 즉, 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 표현해도 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.

이때 변수 선언과 값의 할당의 실행 시점이 다르다는 것이 중요하다. **변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전**에 먼저 실행되지만, **값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임**에 실행된다.

### 값의 재할당

```jsx
var result = 30;
result = 50;
```

위에서 언급했듯 `var` , `let` 키워드는 값의 재할당이 가능한데, 이전 값이 저장되어있던 메모리 공간을 지우고 그 공간에 새롭게 저장하는것이 아닌 새로운 메모리 공간을 확보하여 저장한다.

그렇다면 재할당되어 더이상 사용되지 않는 이전 값은 어떻게 될까? 아무도 사용하지 않는 불필요한 값은 **가비지 콜렉터**에 의해 메모리에서 자동 해제된다. (언제 해제될지는 예측 불가)
